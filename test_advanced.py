#!/usr/bin/env python3
"""
Test Suite Avansat pentru XOFlowers AI Agent
TesteazƒÉ toate func»õionalitƒÉ»õile cu datele reale
"""

import requests
import json
import time
import sys
from datetime import datetime

# Configuration
BASE_URL = "http://localhost:5000"
TEST_USER_ID = "test_advanced_user"

def print_section(title):
    """Print a styled section header"""
    print("\n" + "="*60)
    print(f"üß™ {title}")
    print("="*60)

def print_subsection(title):
    """Print a styled subsection header"""
    print(f"\nüî∏ {title}")
    print("-"*40)

def test_chat_with_real_data():
    """Test chat functionality with realistic XOFlowers queries"""
    
    print_section("TESTARE CHAT CU DATE REALE XOFLOWERS")
    
    # Realistic Romanian queries that customers might ask
    test_queries = [
        {
            "message": "Salut! Vreau trandafiri ro»ôii pentru iubita mea",
            "expected_intent": "find_product",
            "description": "CƒÉutare trandafiri romantici"
        },
        {
            "message": "Ave»õi buchete pentru nuntƒÉ √Æn culori pastel?",
            "expected_intent": "find_product", 
            "description": "CƒÉutare buchete nuntƒÉ"
        },
        {
            "message": "C√¢t costƒÉ livrarea √Æn Chi»ôinƒÉu?",
            "expected_intent": "ask_question",
            "description": "√éntrebare despre livrare"
        },
        {
            "message": "Vreau sƒÉ mƒÉ abonez la flori lunare",
            "expected_intent": "subscribe",
            "description": "Cerere abonament"
        },
        {
            "message": "Am gƒÉsit ceea ce vreau, cum pot plƒÉti?",
            "expected_intent": "pay_for_product",
            "description": "Procesare platƒÉ"
        },
        {
            "message": "Cutii cu bujori pentru ziua mamei",
            "expected_intent": "find_product",
            "description": "CƒÉutare specificƒÉ bujori"
        },
        {
            "message": "Difuzoare de aromƒÉ Chando ieftine",
            "expected_intent": "find_product",
            "description": "CƒÉutare difuzoare cu pre»õ"
        },
        {
            "message": "Aranjamente florale pentru birou, modern »ôi elegant",
            "expected_intent": "find_product",
            "description": "CƒÉutare aranjamente business"
        }
    ]
    
    success_count = 0
    
    for i, test in enumerate(test_queries, 1):
        print(f"\nüß™ Test {i}: {test['description']}")
        print(f"üìù Query: '{test['message']}'")
        
        try:
            response = requests.post(
                f"{BASE_URL}/api/chat",
                json={"message": test["message"], "user_id": f"{TEST_USER_ID}_{i}"},
                timeout=15
            )
            
            if response.status_code == 200:
                data = response.json()
                print(f"‚úÖ Response received ({len(data['response'])} chars)")
                print(f"ü§ñ Agent response preview: {data['response'][:150]}...")
                
                # Test intent recognition separately
                intent_response = requests.post(
                    f"{BASE_URL}/api/test",
                    json={"message": test["message"]},
                    timeout=10
                )
                
                if intent_response.status_code == 200:
                    intent_data = intent_response.json()
                    detected_intent = intent_data['intent']['name']
                    confidence = intent_data['intent']['confidence']
                    
                    print(f"üéØ Intent: {detected_intent} (confidence: {confidence:.2f})")
                    print(f"üè∑Ô∏è  Entities: {intent_data.get('entities', {})}")
                    
                    if detected_intent == test['expected_intent']:
                        print("‚úÖ Intent detection: CORRECT")
                    else:
                        print(f"‚ö†Ô∏è  Intent detection: Expected {test['expected_intent']}, got {detected_intent}")
                
                success_count += 1
                
            else:
                print(f"‚ùå Chat failed: {response.status_code}")
                
        except Exception as e:
            print(f"‚ùå Error: {e}")
        
        time.sleep(1)  # Be respectful to the server
    
    print(f"\nüìä Chat Tests Summary: {success_count}/{len(test_queries)} successful")
    return success_count == len(test_queries)

def test_advanced_product_search():
    """Test advanced product search with ChromaDB"""
    
    print_section("TESTARE CƒÇUTARE AVANSATƒÇ PRODUSE")
    
    search_tests = [
        {
            "query": "trandafiri ro»ôii romantici",
            "filters": {"color": "ro»ôu", "occasion": "romantic"},
            "description": "CƒÉutare trandafiri ro»ôii romantici"
        },
        {
            "query": "buchete ieftine sub 500 lei",
            "filters": {"price_range": "budget"},
            "description": "CƒÉutare buchete buget limitat"
        },
        {
            "query": "cutii elegante pentru nuntƒÉ",
            "filters": {"category": "Basket", "occasion": "wedding"},
            "description": "CƒÉutare cutii pentru nuntƒÉ"
        },
        {
            "query": "bujori roz de sezon",
            "filters": {"flower_type": "Peonies", "color": "roz"},
            "description": "CƒÉutare bujori specifici"
        },
        {
            "query": "difuzoare aromƒÉ premium",
            "filters": {"category": "Chando", "price_range": "premium"},
            "description": "CƒÉutare difuzoare premium"
        }
    ]
    
    success_count = 0
    
    for i, test in enumerate(search_tests, 1):
        print_subsection(f"Test CƒÉutare {i}: {test['description']}")
        
        try:
            response = requests.post(
                f"{BASE_URL}/api/products/search",
                json={
                    "query": test["query"],
                    "filters": test["filters"],
                    "n_results": 5
                },
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                products = data.get('products', [])
                
                print(f"‚úÖ Found {len(products)} products")
                
                if products:
                    print("üèÜ Top results:")
                    for j, product in enumerate(products[:3], 1):
                        similarity = int(product.get('similarity', 0) * 100)
                        price = int(product.get('price', 0))
                        print(f"   {j}. {product['name']} - {price} MDL ({similarity}% match)")
                        print(f"      Category: {product.get('category', 'N/A')}")
                        if product.get('colors'):
                            print(f"      Colors: {', '.join(product['colors'][:3])}")
                
                # Validate filters were applied
                filter_validation = True
                for product in products:
                    if test["filters"].get("price_range") == "budget":
                        if product.get('price', 0) > 500:
                            filter_validation = False
                            break
                
                if filter_validation:
                    print("‚úÖ Filter validation: PASSED")
                else:
                    print("‚ö†Ô∏è  Filter validation: Some results don't match filters")
                
                success_count += 1
                
            else:
                print(f"‚ùå Search failed: {response.status_code}")
                
        except Exception as e:
            print(f"‚ùå Error: {e}")
    
    print(f"\nüìä Search Tests Summary: {success_count}/{len(search_tests)} successful")
    return success_count == len(search_tests)

def test_collections_and_data_integrity():
    """Test ChromaDB collections and data integrity"""
    
    print_section("TESTARE INTEGRITATE DATE »òI COLEC»öII")
    
    try:
        # Test collections info
        response = requests.get(f"{BASE_URL}/api/collections", timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            collections = data.get('collections', {})
            
            print("üìö ChromaDB Collections Status:")
            total_products = 0
            
            for name, info in collections.items():
                count = info.get('count', 0)
                status = info.get('status', 'unknown')
                total_products += count
                
                status_emoji = "‚úÖ" if status == "active" else "‚ö†Ô∏è"
                print(f"   {status_emoji} {name}: {count} products ({status})")
            
            print(f"\nüìä Total products in database: {total_products}")
            
            # Verify we have the expected amount (should be close to 709)
            if total_products >= 700:
                print("‚úÖ Data integrity: Expected product count achieved")
            elif total_products >= 500:
                print("‚ö†Ô∏è  Data integrity: Partial data loaded")
            else:
                print("‚ùå Data integrity: Insufficient data loaded")
                
            return total_products >= 500
            
        else:
            print(f"‚ùå Collections test failed: {response.status_code}")
            return False
            
    except Exception as e:
        print(f"‚ùå Error testing collections: {e}")
        return False

def test_multilingual_capabilities():
    """Test multilingual support"""
    
    print_section("TESTARE CAPABILITƒÇ»öI MULTILINGVE")
    
    multilingual_tests = [
        {
            "message": "Hello, I want red roses for Valentine's Day",
            "language": "English",
            "expected_response_contains": ["roses", "valentine", "red"]
        },
        {
            "message": "–ü—Ä–∏–≤–µ—Ç, —Ö–æ—á—É –±–µ–ª—ã–µ —Ç—é–ª—å–ø–∞–Ω—ã –¥–ª—è –¥–Ω—è —Ä–æ–∂–¥–µ–Ω–∏—è",
            "language": "Russian", 
            "expected_response_contains": ["—Ç—é–ª—å–ø–∞–Ω", "–±–µ–ª—ã–µ", "–¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è"]
        },
        {
            "message": "BunƒÉ, vreau buchete pentru nuntƒÉ √Æn culori albe",
            "language": "Romanian",
            "expected_response_contains": ["buchete", "nuntƒÉ", "albe"]
        }
    ]
    
    success_count = 0
    
    for i, test in enumerate(multilingual_tests, 1):
        print_subsection(f"Test {test['language']}")
        print(f"üìù Message: '{test['message']}'")
        
        try:
            response = requests.post(
                f"{BASE_URL}/api/chat",
                json={"message": test["message"], "user_id": f"multilingual_user_{i}"},
                timeout=15
            )
            
            if response.status_code == 200:
                data = response.json()
                response_text = data['response'].lower()
                
                print(f"‚úÖ Response received")
                print(f"ü§ñ Response preview: {data['response'][:100]}...")
                
                # Check if response is contextually appropriate
                if len(response_text) > 50:  # Non-trivial response
                    print("‚úÖ Response quality: Substantial")
                    success_count += 1
                else:
                    print("‚ö†Ô∏è  Response quality: Brief")
                
            else:
                print(f"‚ùå Request failed: {response.status_code}")
                
        except Exception as e:
            print(f"‚ùå Error: {e}")
    
    print(f"\nüìä Multilingual Tests Summary: {success_count}/{len(multilingual_tests)} successful")
    return success_count >= len(multilingual_tests) * 0.7  # 70% success rate acceptable

def test_performance_and_load():
    """Test performance with multiple concurrent requests"""
    
    print_section("TESTARE PERFORMAN»öƒÇ »òI √éNCƒÇRCARE")
    
    print("üöÄ Testing response times...")
    
    response_times = []
    queries = [
        "trandafiri ro»ôii",
        "buchete nuntƒÉ", 
        "cutii flori",
        "bujori roz",
        "difuzoare aromƒÉ"
    ]
    
    for i, query in enumerate(queries, 1):
        print(f"   Testing query {i}: '{query}'")
        
        start_time = time.time()
        
        try:
            response = requests.post(
                f"{BASE_URL}/api/chat",
                json={"message": query, "user_id": f"perf_user_{i}"},
                timeout=10
            )
            
            end_time = time.time()
            response_time = end_time - start_time
            response_times.append(response_time)
            
            if response.status_code == 200:
                print(f"      ‚úÖ Response time: {response_time:.2f}s")
            else:
                print(f"      ‚ùå Failed: {response.status_code}")
                
        except Exception as e:
            print(f"      ‚ùå Error: {e}")
    
    if response_times:
        avg_time = sum(response_times) / len(response_times)
        max_time = max(response_times)
        min_time = min(response_times)
        
        print(f"\nüìä Performance Summary:")
        print(f"   Average response time: {avg_time:.2f}s")
        print(f"   Fastest response: {min_time:.2f}s")
        print(f"   Slowest response: {max_time:.2f}s")
        
        if avg_time < 3.0:
            print("‚úÖ Performance: EXCELLENT (< 3s average)")
        elif avg_time < 5.0:
            print("‚úÖ Performance: GOOD (< 5s average)")
        else:
            print("‚ö†Ô∏è  Performance: SLOW (> 5s average)")
            
        return avg_time < 10.0  # Acceptable if under 10s
    
    return False

def run_comprehensive_test_suite():
    """Run all tests in sequence"""
    
    print("üå∏ XOFlowers AI Agent - Comprehensive Test Suite")
    print(f"üïê Started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("="*80)
    
    # Test server connectivity first
    try:
        response = requests.get(f"{BASE_URL}/", timeout=5)
        if response.status_code != 200:
            print("‚ùå Server is not responding correctly!")
            print("Please ensure the app is running with: python app.py")
            return False
        
        print("‚úÖ Server connectivity: OK")
        server_info = response.json()
        print(f"üîß Version: {server_info.get('version', 'Unknown')}")
        
    except Exception as e:
        print(f"‚ùå Cannot connect to server: {e}")
        print("Please ensure the app is running with: python app.py")
        return False
    
    # Run all test suites
    test_results = []
    
    test_results.append(("Chat with Real Data", test_chat_with_real_data()))
    test_results.append(("Advanced Product Search", test_advanced_product_search()))
    test_results.append(("Data Integrity", test_collections_and_data_integrity()))
    test_results.append(("Multilingual Support", test_multilingual_capabilities()))
    test_results.append(("Performance", test_performance_and_load()))
    
    # Summary
    print_section("SUMAR FINAL TESTARE")
    
    passed_tests = 0
    total_tests = len(test_results)
    
    for test_name, result in test_results:
        status = "‚úÖ PASSED" if result else "‚ùå FAILED"
        print(f"   {test_name}: {status}")
        if result:
            passed_tests += 1
    
    success_rate = (passed_tests / total_tests) * 100
    print(f"\nüìä Overall Success Rate: {passed_tests}/{total_tests} ({success_rate:.1f}%)")
    
    if success_rate >= 80:
        print("üéâ EXCELLENT! Your XOFlowers agent is working great!")
    elif success_rate >= 60:
        print("‚úÖ GOOD! Most functionality is working correctly.")
    else:
        print("‚ö†Ô∏è  NEEDS IMPROVEMENT! Several issues need attention.")
    
    print(f"\nüïê Completed at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    return success_rate >= 60

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "--quick":
        # Quick test mode
        print("üöÄ Quick Test Mode")
        test_chat_with_real_data()
    else:
        # Full comprehensive test
        success = run_comprehensive_test_suite()
        sys.exit(0 if success else 1)
